""" Problem 29: Distinct Powers

https://projecteuler.net/problem=29

Goal: Count the distinct terms in a sequence generated by a^b when 2 <= a <= N
and 2 <= b <= N.

Constraints: 2 <= N <= 1e5

e.g.: N = 4
      terms = {4, 8, 16}, {9, 27, 81}, {16, 64, 256}
      count = 8
"""


def distinct_powers_brute(n: int) -> int:
    """
    SPEED (WORST)
        1.01s for N = 1e3
    """

    return len(set([pow(a, b) for b in range(2, n+1) for a in range(2, n+1)]))


def distinct_power(n: int) -> int:
    """
    Solution finds the amount of duplicate terms produced by a^b and subtracts
    that from the maximum integer combinations, (n - 1)^2. No need to
    calculate base 2 exponents larger than 16 since 2^17 > 1e5 (upper constraint).

    SPEED (BETTER)
        6.63ms for N = 1e3
    """

    max_exponent = 16
    exponents = [0]*((n+1)*max_exponent)
    for i in range(1, max_exponent + 1):
        for j in range(1, n + 1):
            if exponents[i * j] == 0:
                exponents[i * j] = i
    bases = [0]*(n+1)
    duplicates = 0
    for num in range(2, n + 1):
        parent = bases[num]
        if parent == 0:
            power = num * num
            while power <= n:
                bases[power] = num
                power *= num
            continue
        exponent = 0
        reduce = num
        while reduce > 1:
            reduce /= parent
            exponent += 1
        for y in range(2, n + 1):
            if exponents[y * exponent] < exponent:
                duplicates += 1
    return pow(n - 1, 2) - duplicates


def distinct_power_improved(n: int) -> int:
    """
    Identical solution to that above except that loop ranges reduced by pulling
    max_exponent value even further down.

    SPEED (BEST)
        4.03ms for N = 1e3
    """

    max_exponent = min(16, n - 1)
    min_exponents = [0]*(n*max_exponent-1)
    for i in range(1, max_exponent + 1):
        for j in range(2, n + 1):
            if min_exponents[(i * j) - 2] == 0:
                min_exponents[(i * j) - 2] = i
    bases = [0]*(n-1)
    duplicates = 0
    exponent_duplicates = [0]*(max_exponent-1)
    for num in range(2, n + 1):
        parent = bases[num - 2]
        if parent == 0:
            power = num * num
            while power <= n:
                bases[power - 2] = num
                power *= num
        else:
            exponent = 0
            reduce = num
            while reduce > 1:
                reduce /= parent
                exponent += 1
            if exponent_duplicates[exponent - 2] != 0:
                duplicates += exponent_duplicates[exponent - 2]
            else:
                dupes = 0
                for y in range(2, n + 1):
                    if min_exponents[(y * exponent) - 2] < exponent:
                        dupes += 1
                exponent_duplicates[exponent - 2] = dupes
                duplicates += dupes
    return pow(n - 1, 2) - duplicates
