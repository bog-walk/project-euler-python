""" Problem 61: Cyclical Figurate Numbers

https://projecteuler.net/problem=61

Goal: Given a set of N numbers representing a polygonal, find the sum of a set of
N 4-digit numbers that respect the cyclical properties described below. If multiple
such sets exist, return all their sums in sorted order.

Constraints: 3 <= N <= 6, from {3,4,5,6,7,8}

Cyclic set: In this context, this means the last 2 digits of each number is the
first 2 digits of the next number (including the last number with the first).

Figurate/Polygonal numbers are generated by the formulae ->
Triangle: P_3n = n(n + 1)/2 -> 1, 3, 6, 10, 15, ...
Square: P_4n = n^2 -> 1, 4, 9, 16, 25, ...
Pentagonal: P_5n = n(3n - 1)/2 -> 1, 5, 12, 22, 35, ...
Hexagonal: P_6n = n(2n - 1) -> 1,6, 15, 28, 45, ...
Heptagonal: P_7n = n(5n - 3)/2 -> 1, 7, 18, 34, 55, ...
Octagonal: P_8n = n(3n - 2) -> 1, 8, 21, 40, 65, ...

e.g. {8128, 2882, 8281} is the only cyclical set of 3 4-digit numbers to represent
polygonal types -> {P_3-127, P_5-44, P_4-91}.

e.g.: N = {3, 4, 5}
      cyclical set = {8128, 2882, 8281}
      sum = 19291
"""
from math import floor, sqrt
from util.maths.reusable import is_hexagonal_number, is_triangular_number, \
    is_pentagonal_number


def is_square_number(s_n: int) -> int | None:
    """
    Derivation solution is based on the formula:

    n^2 = s_n, in quadratic form becomes:

    0 = n^2 + 0 - s_n, with a, b, c = 1, 0, -s_n

    putting these values in the quadratic formula becomes:

    n = 0 +/- sqrt(0 + 4s_n) / 2

    so the inverse function, positive solution becomes:

    n = sqrt(s_n)

    :returns: s_n's corresponding term if square, or None.
    """

    n = sqrt(s_n)
    return int(n) if n == floor(n) else None


def is_heptagonal_number(h_n: int) -> int | None:
    """
    Derivation solution is based on the formula:

    n(5n - 3)/2 = h_n, in quadratic form becomes:

    0 = 5n^2 - 3n - 2h_n, with a, b, c = 5, -3, -2h_n

    putting these values in the quadratic formula becomes:

    n = 3 +/- sqrt(9 + 40h_n) / 10

    so the inverse function, positive solution becomes:

    n = 0.1 * (3 + sqrt(9 + 40h_n))

    :returns: h_n's corresponding term if heptagonal, or None.
    """

    n = 0.1 * (3 + sqrt(9 + 40 * h_n))
    return int(n) if n == floor(n) else None


def is_octagonal_number(o_n: int) -> int | None:
    """
    Derivation solution is based on the formula:

    n(3n - 2) = o_n, in quadratic form becomes:

    0 = 3n^2 - 2n - o_n, with a, b, c = 3, -2, -o_n

    putting these values in the quadratic formula becomes:

    n = 2 +/- sqrt(4 + 12o_n) / 6

    so the inverse function, positive solution becomes:

    n = (1 + sqrt(1 + 3h_n)) / 3

    :returns: o_n's corresponding term if octagonal, or None.
    """

    n = (1 + sqrt(1 + 3 * o_n)) / 3
    return int(n) if n == floor(n) else None


def get_polygons(polygons: set[int]) -> list[list[int]]:
    """
    Generates all 4-digit figurate/polygonal numbers for the polygons specified.

    N.B. Numbers with a 0 in the 3rd position are filtered out as these will
    not allow the cyclic property to occur. e.g. 2701 (P_6_37) -> 01xx, which is
    not a 4-digit number.

    :param polygons: Set of Integers in [3, 8] representing triangle,...octagonal
        polygons.
    :returns: Nested lists of all requested 4-digit figurate numbers, found at the
        index matching their polygonal value. e.g. All triangle numbers between
        1000 and 9999 stored at index 3.
    """

    formulae = [
        is_triangular_number, is_square_number, is_pentagonal_number,
        is_hexagonal_number, is_heptagonal_number, is_octagonal_number
    ]
    all_polygons = [[] for _ in range(9)]
    for p in polygons:
        all_polygons[p] = list(
            filter(
                lambda num: str(num)[2] != '0' and formulae[p-3](num) is not None,
                range(1010, 10_000)
            )
        )
    return all_polygons


def cyclical_figurates(polygons: set[int]) -> list[list[int]]:
    """
    Solution uses recursion to search for cyclic chains using the smallest
    polygonal set numbers as starters (e.g. there will be fewer octagonal numbers
    that triangle numbers to start chains).

    A separate stack of the remaining polygon numbers to find is cached so the
    search can continue if a chain that cannot close its first and last elements
    is reached. This is done by remembering the last polygon added to the chain &
    adding it back to the stack it was just popped from if the chain becomes invalid.

    Rather than searching for a final figurate that closes the chain, the expected
    number is checked to see if it is in the generated polygon list.

    :returns: List of all cyclic lists that represent the polygons requested.
    """

    cycles = []
    not_found = list(polygons)
    all_polygons = get_polygons(polygons)

    def next_cyclical(
            prefix: int,
            last_found: int,
            chain: list[int]
    ) -> list[int]:
        if len(not_found) == 1:
            expected = chain[-1] % 100 * 100 + chain[0] // 100
            if expected in all_polygons[not_found[0]]:
                not_found.pop()
                return chain + [expected]
            else:
                chain.pop()
                not_found.append(last_found)
                return chain
        else:
            for p in polygons:
                if p in not_found:
                    for number in all_polygons[p]:
                        if number in chain:
                            continue
                        if prefix < number // 100:
                            break
                        if prefix == number // 100:
                            chain.append(number)
                            not_found.remove(p)
                            chain = next_cyclical(number % 100, p, chain)
                            if len(not_found) == 0:
                                return chain
            else:
                chain.pop()
                not_found.append(last_found)
                return chain

    smallest = max(not_found)
    for starter in all_polygons[smallest]:
        cycle = [starter]
        not_found.remove(smallest)
        cycle = next_cyclical(starter % 100, smallest, cycle)
        if len(cycle) == len(polygons):
            cycles.append(cycle)
            not_found = list(polygons)
    return cycles
